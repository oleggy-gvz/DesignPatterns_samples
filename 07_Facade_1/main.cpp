/*
 * Вместо работы с низкоуровневыми абстракциями по отдельности, реализуем паттерн "Фасад", абстракцию уровнем выше. Т.е. создаем некий обобщающий класс
 * в который в качестве компонентов передаем те подсистемы которые выполняют конкретную работу. Сам обобщенный клас не делает никаких операций, он
 * делегирует все вызовы тем подсистемам которые используются внутри него.
 *
 * В нашем случае создаем класс Стиральная машина (WashingMachine), в данном класе создаем два метода: стирка хлопка (WashCotton) и стирка шерсти (WashWool).
 * В данные методы переносим всю последовательность действий для стирки хлопка и для стирки шерсти.
 *
 * Фасад может использоватся в различных более крупных системах когда есть множество подсистем которые сложны для использования по отдельности или даже
 * связаны между собой через различные третьи системы. Для пользователя лучше реализовать паттерн Фасад где всю эту работу третьих систем срыть от пользователя.
 *
 * Пример: системы доступа к данным, система работы с отчетами, система работы с БД, система вызова внешних команд. Они все сложны в использовании по
 * отдельности, так же могут быть связаны между собой. К примеру система работы с БД, возвращает объект соединения с этой БД, и без этого объекта не может
 * работать система отчетов. С введением фасада при работе с этой системой отчетов, то эта система уже будет иметь какое либо представление о системе
 * работы с БД и иметь тот самый объект соединения с этой БД, который хранится внутри этой БД.
 *
 * Проблема проектирования:
 * -----------------------
 * При взаимодействии с каким-либо объектом мы должны взаимодейстовать только сним и не с кем больше.
 * внутри метода какого либа объекта могут вызыватся лишь:
 * 1. методы которые принадлежать самому объекту
 * 2. методы объекта который были переданы в наш текущий метод в качестве параметров
 * 3. объекты которые были созданы внутри нашего метода
 * 4. поля самого объекта
 *
 * Если обобщенный класс возвращает пользователю какой то низкоуровненный объект (который содержится внутри этого класса), то нежелательно вызывать
 * (со стороны пользователя) метод низкоуровневого объекта через полученный объект.
 * Нужно внутри обобщенного класса реализовать новый метод, в котором через имеющийся в нем низкоуровневый объект вызвать этот метод.
 * Пример: temp = washingMachine.GetThermometer().GetTemperature() - неверно, нужно внутри коласса WashingMachine реализовать метод GetTemperature()
 * где внутри которого прописать: return _thermo->GetTemperature().
 *
 */

#include <iostream>
#include "WashingMachine\WaterManagingSubsystem.h"
#include "WashingMachine\Dryer.h"
#include "WashingMachine\Engine.h"
#include "WashingMachine\Thermo.h"
#include "WashingMachine\WashingMachine.h"
#include <memory>

using namespace std;

int main()
{
    shared_ptr<Dryer> dryer(new Dryer());
    shared_ptr<Engine> engine(new Engine());
    shared_ptr<Thermo> thermo(new Thermo());
    shared_ptr<WaterManagingSubsystem> water(new WaterManagingSubsystem());
    shared_ptr<WashingMachine> washingMachine(new WashingMachine(dryer, engine, thermo, water));

    cout << "Cotton" << endl; // для хлопока
    washingMachine->WashCotton();
    cout << endl;

    cout << "Wool" << endl; // для шерсти
    washingMachine->WashWool();
    cout << endl;

    return 0;
}
