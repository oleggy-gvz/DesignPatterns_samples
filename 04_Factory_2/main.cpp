/*
 *
 * ФАБРИЧНЫЙ МЕТОД
 * ---------------
 * Вся суть фабричного метода заключается в том, что у нас есть два абстрактных класса (VolkswagenFacility) и (Car). И сами эти два абстрактных класса зависят только
 * друг от друга, не от реализации. А уже конкретный фабрики  (....VolkswagenFacility) зависят от конкретных реализаций. Тем самым снижается зависимость между объектами.
 * Если будем пользоватся только базовыми абстрактными классами (VolkswagenFacility) и (Car) то тем самым мы избеаем сильной связанности объектов. Иззбегаем зависимости от
 * реализации и тем самым делаем более гибкое ПО, которое позволяет нам каким либо образом модифицировать самого себя не изменяя основной код программы.
 *
 * Паттерн позволяет определить общий интерфейс создания объектов (продуктов), при этом позволяя субклассам (....VolkswagenFacility) выбирать конкретный продукт для создания.
 * Другими словами - паттерн Фабричный метод инкапсулирует создание объектов внутри себя.
 * Внешний пользователь фабрики не знает как был создан тот или иной продукт, который он получает из этой фабрики. Он получает из нее лишь некий абстрактный класс,
 * обладающий необходимым набором методов. То каким образом был получен этот объект и то, что это за конкретный объект (какая реализация у этого объекта) пользователь фабрики
 * не знает, т.к. все сокрыто внутри фабричного метода той самой фабрики.
 *
 * Проблемы проектирования
 * -----------------------
 * Имеется много дублированных классов автомобилей - Немецких/Российских, отличающихся ненамного друг от друга (по цвету/двигателю/колесам) что очень нехорошо.
 * Т.е. для каждого рынка (российского / немецкого) свой набор классов автомобилей для одной и той же модели. При добавлении нового рынка - свой класс.
 */

#include <iostream>
#include <string>
#include "Facilities\DeutschVolkswagenFacility.h"

int main()
{
    shared_ptr<VolkswagenFacility> facility(new DeutschVolkswagenFacility());

    facility->GetCar("Golf");
    cout << endl;

    facility->GetCar("Passat");
    cout << endl;

    facility->GetCar("Tiguan");
    cout << endl;

    facility->GetCar("Tuareg");
    cout << endl;

    return 0;
}
