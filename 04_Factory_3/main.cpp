/*
 * в этом примере рассматривается: АБСТРАКТНАЯ ФАБРИКА (расширенный ФАБРИЧНЫЙ МЕТОД, расширяемся до фабрик запчастей)
 * -------------------------------------------------
 * Разные регионы - разные компоненты
 * Однако кое-где есть схожие компоненты
 * Надо контролировать и унифицировать процесс их создания
 *
 * Необходимо создать несколько семейств фабриик. Отдельно фабрика машин (...VolkswagenFacility), отдельно фабрика компонентов (классы ....CarPartsFactory).
 * Получается три различных иерархии: иерархия самих автомобилей (дир. Car), иерархия фабрик по сборке этих автомобилей (дир. Facilities), иерархия фабрик по сборке
 * запчастей для этих автомобилей.
 * Данные фабрики не зависят друг от друга, а зависят только от базовых классов самих этих структур: VolkswagenFacility зависит от сущности Car, CarPartsFactory
 * зависит от сущности Engine, Paint, Wheels.
 *
 * ИТОГ
 * ----
 * Предоствляет интерфейс создания взаимосвязанных или взаимозависимых объектов без указания их конретных типов.
 *
 * Отличия Абстрактная фабрика - Фабричный метод:
 * Фабричный метод использует наследование, призван создавать лишь один продукт.
 * Абстрактная фабрика использует композицию, призвана создавать семейство продуктов сразу.
 */

#include "Facilities\DeutschVolkswagenFacility.hpp"
#include "Facilities\RussianVolkswagenFacility.hpp"
#include <iostream>

using namespace std;

int main()
{
    shared_ptr<VolkswagenFacility> facility(new RussianVolkswagenFacility());

    facility->GetCar("Golf");
    cout << endl;

    facility->GetCar("Passat");
    cout << endl;

    facility->GetCar("Tiguan");
    cout << endl;

    facility->GetCar("Tuareg");
    cout << endl;

    return 0;
}
