/*
 * ПАТТЕРН "СОСТОЯНИЕ"
 *
 * Применяется тогда, когда нам нужно во время выполнения программы поменять объекту свое поведение в зависимости от состояния.
 * Т.е. когда у нас есть система с четко выраженными состояниями.
 * Принципы:
 * 1. Выносим поведение в отдельную иерархию классов. Каждый из которых будет реализовывать конкретное состояние данного объекта.
 * 2. Выносим поведение в зависимости от конкретного состояния внутрь того или иного класса того или иного объекта.
 * 3. Делегируем выполнение поведения тем самым классам состояния который вы только что реализовали.
 *
 * Польза:
 * 1. Поведение описывается на уровне состояния.
 * Если раньше был метод в котором отдельно реализовано различное поведение в зависимости от состояния, то в новом подходе в зависимости от паттерна State
 * реализуем состояние и в нем описываем логику поведения которая относится только к этому состоянию. Это сокращает кол-во кода и делает более понятным для
 * тех кто с ним работает.
 * 2. Избавляемся от громоздких конструкций с использованием if-else if.
 * 3. Ввод нового состояни происходит легко и без модификации объекта.
 *
 * Необходимо уйдти от проверки цепочки состояний машины в каждом методе. Для этого необходимо реализовать некий "интерфейс" который будет описывать
 * в себе те 4-е метода которые мы хотим получить в нашем автомобиле. Далее необходимо реализовать отдельные классы по каждому состоянию
 * (Бензина нет, Бензин есть, Мотор запущен, Машина едет). Далее в классе Car будем вызывать вместо конкретных методов по каждому состоянию,
 * метод текущего стостояния, т.к. состояние будет у нас не просто enum а полноценный класс. Т.е. будем делегировать выполнение этого метода самому
 * классу состояния, вместо того что бы выполнять его самостоятельно в классе Car.
 *
 * Итог:
 * -----
 * В классе Car так же имеется 4 метода из которых убран перебор состояний. Весь код который присутствовал в них стал "размазан" по 4-ем классам состояний
 * который мы реализовали отдельно.Т.е. весь перебора состояний был убран и каждая проверка состояния перенесена в соответствующий класс каждого состояни.
 * Для этого был создан дубликат этих 4-х методов в каждом классе состояния.
 * Далее в качестве действия производимого внутри 4-х методов класса Car было реализован лишь вызов соответствующих методов из объекта текущего класса состояний.
 * Логика переключениястатусов состояний перенесена из класса Car в класс состояния.
 *
 * 1. Делегировать выполнение операций некоему новому классу. Для этого создаем либо интерфейс (абстрактный класс), в котором был тот самый метод который
 * необходимо делегировать.
 * 2. Для управления состояниями внутри нашего класса текущего объекта реализовать эти самые состояния внутри себя (как бы сформировать и запомнить на будущее)
 * 3. Предоставить внешнему миру возможность переключать эти состояния внутри себя (setState, getState).
 *
 */

#include "Car.h"

using namespace std;

int main()
{
    shared_ptr<Car> car(new Car());
    car->FillTank();
    car->TurnKey();
    car->TurnKey();
    car->TurnKey();
    car->Drive();
    car->Stop();

    system("pause");
    return 0;
}
