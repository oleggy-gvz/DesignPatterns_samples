/*
 * Симулятор меню напитков в кофейне. Базовый напиток(BeverageBase), абстрактный класс в котором реализовано: поле описание (Description) и метод узнать цену (GetCost()).
 * На основе данного класса реализованы напитки Эспрессо (Espresso), Капуччино (Capuccino), Чай (BlackTea).
 *
 * Проблема проектирования:
 * -----------------------
 * Программирование на уровне реализации, а должны на уровне интерфейса. Использовали наследование, а должны комозицию.
 *
 * В нашем случае при добавлении еще нескольких видов напитков, значит столько же классов нужно будет создать. Проблема заключается в том что при создании напитка к примеру
 * "Какао с сахором", это значит что это отдельный напиток, значит отдельная реализация класса. Далее, "Латте с сахаром" либо наоборот с меньшим кол-вом молока, значит
 * нужно создавать еще один класс. В итоге у каждого напитка может быть вариация "с сахаром", "без сахара", "с молоком", "без молока", "с двойной порцией", "без двойной порции"
 * и т.д. Будет создано огромное кол-во объектов которое СЛОЖНО поддается нормальному контролю.
 * Далее при изменении цены например на молоко, мы вынуждены менять цену ВРУЧНУЮ у всех таких напитков у которых в составе есть молоко, для этого ВРУЧНУЮ анализировать
 * какие классы имеют в составе молоко, модифицировать их код.
 *
 * Паттерн "Декоратор"
 * - Наследование интерфейса а не поведения
 *      Т.е. создание CondimentsDecoratorBase означало что мы создали не напиток, а что то на него похожее, что бы другие считали его напитком, поэтому и были наследованы
 *      от BeverageBase, но для того что бы наследовать описание методов, но не их реализацию.
 * - Композиция для расширения поведения
 *      Т.е. помимо наследования имеем приватное поле BeverageBase, которое мы инстанцируем (устанавливаем) с помошью конструктора CondimentsDecoratorBase. Поэтому
 *      с помошью композиции мы можем расширить объект типа BeverageBase, тем поведением которым мы хотим привнести с данным декоратором.
 * - Композиция дает свободу в режиме выполнения
 *      Т.е. мы не привязаны к структуре классов, наследованием, которая является привязкой на этапе компиляции программы а является динамически заменяемой. Можем динамически
 *      заменять объекты композцией (*_beverage), добавлять надстройку над объектом.
 * - Вместо абстрактного класса может быть интерфейс - все зависит от исходной структуры.
 *      Т.е. не обязательно следовать либо интерфейсу либо абстрактному классу, используем то что есть в распоряжении. Если нужно отдекорировать некий класс который разработан
 *      другим разрабодчиком, и известно что этот класс является наследником некой структуры опирающейся на абстрактный класс, то мы наследуемся от абстрактного класса и
 *      реализуем декоратор на этой основе. Если знаем что наш класс для декарирования реализует какой то интерфейс то тогда подстраиваемся под этот интерфейс а не под
 *      абстрактный класс.
 *      Декоратор может нарушить работу программы которая опирается в своей работе на проверку объектов на их тип, т.к. после декорирования тип объекта изменится на
 *      декорируемый.
 */

#include <iostream>
#include <string>
#include "Beverage\BeverageBase.h"
#include "Beverage\Espresso.h"
#include "Beverage\BlackTea.h"
#include "Beverage\GreenTea.h"
#include "Decorator\MilkCondiment.h"
#include "Decorator\SugarCondiment.h"
#include "Decorator\ChocolateCondiment.h"

using namespace std;

void PrintBeverage(shared_ptr<BeverageBase> beverage)
{
    cout << "Beverage: " << beverage->GetDescription() << "; Price: " << beverage->GetCost() << endl;
}

int main()
{
    shared_ptr<BeverageBase> espresso(new Espresso());
    shared_ptr<BeverageBase> blackTea(new BlackTea());
    shared_ptr<BeverageBase> greenTea(new GreenTea());

    PrintBeverage(espresso);
    PrintBeverage(blackTea);
    PrintBeverage(greenTea);

    cout << "---------------" << endl;

    shared_ptr<BeverageBase> capuccino(new SugarCondiment(new MilkCondiment(new Espresso())));
    PrintBeverage(capuccino);

    shared_ptr<BeverageBase> greenTeaWithSugar(new SugarCondiment(new GreenTea()));
    PrintBeverage(greenTeaWithSugar);

    // порядок вызовов деструкторов на примере capuccino
    /*
     * ~SugarCondiment() вход
     *      ~MilkCondiment(), вход, сперва удаление MilkCondiment
     *          ~Espresso(), вход/выход, сперва удаление Espresso
     *          ~BeverageBase(), вход/выход, вызов родит. деструктора Espresso
     *      ~MilkCondiment(), выход
     *      ~CondimentsDecoratorBase(), вызов родит. деструктора MilkCondiment
     *      ~BeverageBase(), вызов еще родит. деструктора MilkCondiment
     * ~SugarCondiment(), выход
     * ~CondimentsDecoratorBase(), вызов родит. деструктора у SugarCondiment
     * ~BeverageBase(), вызов еще родит. деструктора у SugarCondiment
     *
     *  ! если какой то дестроктор не объявлен, значит он пропускается
     */

    return 0;
}
